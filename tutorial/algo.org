#+title: plan
#+author: aaron
#+date: <2021-02-11 Thu 22:07>



** inbox


*** 树状数组bit

*** 线段树 segment tree


zkw 线段树
线段树通常比树状数组更加强大

*** LRU

*** 单调栈

*** b 树

*** 斐波拉契数列

*** 不相交集合

*** van emde boas 树

*** 最小栈

*** 有限自动机算法

*** kmp 算法


*** 位运算

*** 矩阵快速幂

*** 并查集

** 计划内容

*** 可信考试

**** 进阶数据结构梳理

线段树，bit等数据结构


**** 解题模板的总结

提高解题速度

尽快做完



**** 刷题策略


简单题目

多刷两遍

复杂题目


一周刷题指南




*** 公司知识体系构建

将公司的整个知识体系构建起来，并尝试在自己的电脑上复刻

这也符合“听写式学习”的特点，有利于我们提高学习的效率



*** 经典书籍的阅读

- 要做笔记和总结，将知识读薄
- 一定要做习题
- 操作系统，编译原理，图形学，算法，cpp涵盖的内容比较广

依然是以c语言为主，将c语言的精髓融汇贯通，cpp涵盖了一些面向对象的思想，还有一些算法模版，在学习算法和设计模式时，可以着重学习

书单如下：


- tcp ip 详解
- unix 环境系列
- 程序员的自我修养，动态链接，编译与库
- 深入理解计算机系统
- 鸟哥的私房菜
- 算法导论



*** 视频课程

一俩三四五模版算法部分，耗时约20h，两天时间






*** 体育锻炼和睡眠恢复

每天散步




*** 房屋清理


** 数据结构梳理




*** 背包 dp

01 背包问题

符合最优子结构，重复子问题，和无后效性


**** 定义

注意01背包和贪心算法之间的区别

v 代表体积
w 代表重量
vi 代表第i件物品的体积，wi代表第i件物品的重量


- dp[i][j] 代表考虑到，选择前i件物品（可能取第i件，也可能不取），占用了j空间时的所能取到的最大价值
- 

转移方程

放置物品或者不放置物品时的价值

1) 考虑放入第i个物品 dp[i-1][j-vi] + wi
2) 不放入第i个物品 dp[i-1][j]






*** 线段树 segment tree


*** 树状数组 bit


*** 前缀和



** oi 入门


https://vjudge.net/article/6


https://blog.csdn.net/a1dark/article/details/11714009




** 省队阶段冲刺一，查漏补缺


- 思维导图
  + 图论
    + 最短路
      + dijkstra
      + 
    + 差分约束
    + 树和生成树
    + 欧拉回路和哈密顿回路
    + 连通性
    + 网络流
    + 二分图
    + 图的计数
    + 图的度数序列
    + 基础问题
  + 数据结构
    + 树结构
    + 线性结构
    + 数据结构的嵌套
    + 非传统做法
    + 可持久化
    + 复杂度分析
  + 思想与技巧
    + 分块
    + 离线与在线
    + 差分
  + 动态规划
    + 基础模型
    + 原理
    + 优化
  + 贪心
    + 拟阵
    + huffman 编码模型
    + 基于调整法证明贪心
  + 构造
    + 构造答案
    + 构造解
  + 字符串

  + 数学相关
    + 组合数学
    + 线性代数
    + 抽象代数
    + 初等数论
    + 反演变换
    + 高等数学
    + 数值算法
    + 组合游戏
    + 概率统计
    + 多项式相关
  + 计算几何
  + 其他
    + 随机算法
    + 近似算法
    + 搜索
    + 暴力
    + 模拟
      + AI 制作
      + 模拟器实现
      + 编译器实现
      + 游戏实现
      + 麻将



** 洛谷五一专题

- 专题
  - 数学思维专题
    + 整数与取余
    + 质数与筛法
    + 最小公倍数
    + 扩张欧几里得
    + 同余方程
    + 排列组合
    + 思维选讲
    + 数学推导题
  - 动态规划专题
    + 子问题分割
    + 状态与转移
    + 记忆化搜索
    + 背包问题
    + 基础模型
    + 基础动归
    + 应用案例
  - 数据结构专题
    + 线性表
    + 线性优化
    + 使用STL
    + 建树与性质
    + 基础树上问题
    + 序列维护
    + 树状数组
    + 线段树




** 一俩三四五

- 算法
  + 01 链表和双向链表
  + 02 栈
  + 03 二分搜索 三分搜索
  + 04 快速幂 矩阵快速幂
  + 05 图的数据结构
  + 06 广度优先搜索
  + 07 深度优先搜索
  + 08 前缀和 差分
  + 09 并查集
  + 10 计数排序 快速排序
  + 11 动态规划
  + 12 最长公共子序列 最长上升子序列
  + 13 区间DP
  + 14 状态压缩DP
  + 15 树状DP
  + 16 未知
  + 17 KMP算法



















** 邓俊辉数据结构视频


完全二叉堆


串


KMP 算法


非递归算法

可以多看几遍





** 九阴真经

- 九阴真经
  + 01 单调栈
  + 02 并查集
  + 03 滑动窗口
  + 04 前缀和&hash
  + 05 差分
  + 06 拓扑排序
  + 07 字符串
  + 08 二分查找
  + 09 BFS
  + 10 DFS
  + 11 动态规划
  + 12 贪心算法
  + 13 字典树


*** some minds

English is more powerful, and will give you more representing express.

不会做就背答案





**** 算法模版单调栈- 带哨兵


首先要确定是递减还是递增栈

- 01 复制待处理队列，并增加左右哨兵，左右哨兵不得影响结果
- 02 初始化一个栈（单调递减栈）
- 03 压入一个左哨兵
- 04 开始从头遍历队列，遍历处理如下
  - 0401 若当前元素小于等于单调栈的栈顶元素，直接入栈，进行下一轮循环直至遍历结束。否则进入0402
  - 0402 若当前元素大于单调栈的栈顶元素，将元素出栈，并对此元素进行处理，
  - 


**** 算法模版-单调队列   

**** 算法模板-循环结果的处理


存在一个队列，需要处理循环情况

可以参考以下内容

从空间上
复制一个队列，头尾相接，最后处理时，只取左边队列的

从代码上

直接取模就可以达到循环的效果
类似于循环队列的处理方式


**** 算法模版-dfs

**** 算法模版-bfs


**** 算法模版-双指针



**** 算法模版-最长公共子串

**** 算法模版-最长公共子序列


**** 算法模版-最长回文串

**** 回溯

**** 线段树

**** 并查集




**** AC 自动机


trie树
kmp
bfs


*** 84




*** 42 traping rain water

*** labuladuo

https://www.bookstack.cn/read/fucking-algorithm/动态规划系列-README.md



按照顺序，先去读题，找思路，
然后直接找题解



** 上研极客汇

| order | class        | type     | problem_order | done | time_use |
|-------+--------------+----------+---------------+------+----------|
|    01 | 单调栈       | 代表题目 |            84 | y    |       80 |
|       |              |          |           739 | y    |       30 |
|       |              |          |           503 |      |          |
|       |              |          |            85 |      |          |
|       |              |          |            42 |      |          |
|       |              |          |           901 |      |          |
|       |              |          |           239 |      |          |
|       |              |          |           962 |      |          |
|    02 | 并查集       | 代表题目 |           547 |      |          |
|       |              |          |           684 |      |          |
|       |              |          |           200 |      |          |
|       |              |          |           737 |      |          |
|       |              |          |          1102 |      |          |
|       |              |          |          1135 |      |          |
|       |              |          |           261 |      |          |
|       |              |          |          1061 |      |          |
|       |              |          |           323 |      |          |
|       |              |          |           924 |      |          |
|    03 | 滑动窗口     | 代表题目 |          1208 |      |          |
|       |              |          |           209 |      |          |
|       |              |          |             3 |      |          |
|       |              |          |          1004 | y    |       15 |
|       |              |          |           340 |      |          |
|       |              |          |          1151 |      |          |
|       |              |          |           159 |      |          |
|       |              |          |          1100 |      |          |
|    04 | 前缀和与hash |          |           560 | y    |          |
|       |              |          |           974 | y    |          |
|    05 | 差分         | 代表题目 |          1094 |      |          |
|       |              |          |          1109 | y    |       60 |
|       |              |          |           121 | y    |       20 |
|       |              |          |           122 | y    |       20 |
|       |              |          |           253 |      |          |
|    06 | 拓扑排序     | 代表题目 |           210 |      |          |
|       |              |          |           444 |      |          |
|       |              |          |           269 |      |          |
|    07 | 字符串       | 代表题目 |             5 |      |          |
|       |              |          |            93 |      |          |
|       |              |          |            43 |      |          |
|       |              |          |           227 |      |          |
|    08 | 二分查找     | 代表题目 |           240 |      |          |
|       |              |          |             4 |      |          |
|       |              |          |            33 |      |          |
|    09 | BFS          | 代表题目 |           127 |      |          |
|       |              |          |           139 |      |          |
|       |              |          |           130 |      |          |
|       |              |          |           317 |      |          |
|       |              |          |           505 |      |          |
|       |              |          |           529 |      |          |
|       |              |          |          1263 |      |          |
|       |              |          |          1197 |      |          |
|       |              |          |           815 |      |          |
|       |              |          |           934 |      |          |
|    10 | DFS          | 代表题目 |           934 |      |          |
|       |              |          |          1102 |      |          |
|       |              |          |           685 |      |          |
|       |              |          |           531 |      |          |
|       |              |          |           533 |      |          |
|       |              |          |           332 |      |          |
|       |              |          |           337 |      |          |
|       |              |          |           113 |      |          |
|    11 | 动态规划     | 代表题目 |           213 |      |          |
|       |              |          |           361 |      |          |
|       |              |          |          1066 |      |          |
|       |              |          |           750 |      |          |
|       |              |          |          1230 |      |          |
|       |              |          |          1055 |      |          |
|    12 | 贪心算法     | 代表题目 |           452 |      |          |
|       |              |          |          1231 |      |          |
|       |              |          |          1247 |      |          |
|       |              |          |            45 |      |          |
|       |              |          |           621 |      |          |
|       |              |          |           376 |      |          |
|    13 | 字典树       | 代表题目 |           820 |      |          |
|       |              |          |          1231 |      |          |
|       |              |          |           648 |      |          |
|       |              |          |           208 |      |          |



** 差分数组


差分数组

定义

如果有一个数组arr，它的差分数组diffArr定义如下：

diffArr[0] = arr[0]
diffArr[i] = arr[i] - arr[i - 1]
计算

这样，如果要对原始数组arr的[i, j]区间的元素全部加某个值value，对应到其查分数组中时，只需要对查分数组进行如下O(1)复杂度的操作即可。

diffArr[i] += value
diffArr[j + 1] -= value （j + 1 < n时）
还原

把对原始数组的一系列区间加减操作映射到其查分数组的计算操作之后，这个查分数组还原成原数组，即可得到原数组经过这一系列操作之后的状态。还原方法如下：

arr[0] = diffArr[0]
arr[i] = diffArr[i] + arr[i - 1]

#+begin_src go
func corpFlightBookings(bookings [][]int, n int) []int {
	sort.SliceStable(bookings, func(i, j int) bool {
		return bookings[i][0] < bookings[j][0]
	})
	corpFlightA := make([]int, n)
	for _, booking := range bookings {
		if booking[1] <= n {
			for i := booking[0]; i <= booking[1]; i ++ {
				corpFlightA[i - 1] += booking[2]
			}
		}
	}

	return corpFlightA
}
#+end_src



** 算法题解

https://algorithm.yuanbin.me

